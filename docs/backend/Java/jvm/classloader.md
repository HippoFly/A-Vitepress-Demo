# 类加载

## 类加载过程

开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。

- 类加载过程：**加载->连接*->初始化**。
- **连接***过程又可分为三步：**验证->准备->解析**。

![](https://img2.imgtp.com/2024/05/31/vdpeZFkj.png)

1. **加载（Loading）**:

   - 这是类加载过程的第一个阶段。JVM通过类的**全限定名**找到对应的**.class**文件，然后读取文件的二进制数据到内存中，并创建一个`java.lang.Class`对象来代表这个类。这个过程由类加载器（ClassLoader）负责，包括启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、系统类加载器（Application ClassLoader）或用户自定义的类加载器。

2. 链接

   1. **验证（Verification）**:

   - 为了保证类的**正确性**，加载后的字节码需要经过验证，确保其遵守Java**语言规范**和JVM规范，不会对JVM的安全性构成威胁。
   - 验证包括文件格式验证、元数据验证、字节码验证和符号引用验证等多个层次。

   **b. 准备（Preparation）**:

   - 在这个阶段，JVM为类的静态变量分配内存空间，并赋予默认的初始值。例如，int类型的静态变量初始化为0，布尔型为false，引用类型为null。注意，这个阶段不会执行任何Java代码。

   **c. 解析（Resolution）**:

   - 类中的符号引用（如类名、方法名等）被转换为直接引用（实际内存地址）。这个过程可以延迟到运行时进行，即所谓的动态链接，以支持Java的动态绑定特性。

3. **初始化（Initialization）**:

   - 这是类加载过程的最后一步，也是真正执行Java代码的地方。在这个阶段，JVM会执行类的静态初始化块和静态变量的显式赋值操作，以及调用静态初始化器。类的初始化顺序遵循以下规则：
     - 父类的静态成员和静态初始化块先于子类执行。
     - 如果有多个静态初始化块或静态变量，按照它们在代码中的顺序执行。
   - 初始化阶段仅执行一次，除非显式调用了`Class.forName()`或通过反射访问类的静态方法或变量，否则类的初始化是在其主动使用时触发的。

  ## 双亲委派 


   类加载器在接收到类加载的请求时，并**不会立即自己**去尝试加载这个类，而是先将加载请求**委托给其父类加载器**去完成。如果父类加载器能够完成类加载任务，那么子加载器就不需要再尝试加载；如果**父类加载器无法**完成此任务，那么**子加载器才会**尝试自己加载。

   这个过程会**一直向上**委托，直至到达最**顶级**的启动类加载器。如果启动类加载器也未能找到所需加载的类，那么加载请求会逐级回退，由下一级类加载器进行尝试。这种自顶向下的委托模式可以确保类的唯一性，即一个类只会被加载一次，而且是由它最合适的加载器加载。

   ![](https://img2.imgtp.com/2024/05/31/4O07dTo8.png)

   主要优点包括：
   
   1. **避免类的重复加载**：确保了每个类在JVM中只有一个唯一的实例，防止了同一个类被不同的类加载器重复加载。
   2. **避免Java的核心API被篡改**：因为Java的核心库都是由启动类加载器加载的，这样就可以防止用户自定义的类覆盖这些核心类，保护了Java平台的安全性和稳定性。
   3. **支持类加载器的层级体系**：构建了一个从上至下的父子层级关系，使得类的加载过程具有良好的层次性和规划性。