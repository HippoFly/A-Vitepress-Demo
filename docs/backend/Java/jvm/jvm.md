# JVM

## JVM常规

### JVM调优常用命令和参数

常用命令：

1. jps：查看进程及其相关去信息

2. jmap：用来生成dump文件和查看堆相关的各类信息的命令。

3. jstat：查看jvm运行时的状态信息

4. jstack：查看jvm线程快照的命令

5. jinfo：查看jvm参数和动态修改部分jvm参数\

常用参数：

-Xms：初始化堆大小

-Xmx：最大堆大小

-Xmn：新生代的内存空间大小

-XX：SurvivorRatio	

-Xss：每个线程的堆栈大小

-XX：PermSize：设置永久代初始值

XX：MaxPermSize：设置永久代最大值

### **对象的创建**

Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。

*Step1:类加载检查*

虚拟机遇到一条 new 指令时，首先将去检查

1. 这个指令的参数是否能在常量池中定位到这个类的符号引用，
2. 检查这个符号引用代表的类是否已被加载过、解析和初始化过。

如果没有，那必须先执行相应的类加载过程。

*Step2:分配内存*

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞：
    - 适用场合：堆内存规整（即没有内存碎片）的情况下。
    - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：
    - 适用场合：堆内存不规整的情况下。
    - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

*Step3:初始化零值* 

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

*Step4:设置对象头*

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

*Step5:执行 `init` 方法* 

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 内存分布

![](https://img2.imgtp.com/2024/05/31/5BFdHBIw.png)

![](https://img2.imgtp.com/2024/05/31/0ddrpkWp.png)

### 堆内存

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就**是存放对象实例**，几乎所有的对象实例以及**数组都**在这里分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老年代代(Old Generation)
3. 永久代(Permanent Generation)

**JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存**

![](https://img2.imgtp.com/2024/05/31/RLkvAx6g.png)

 **1. 堆 (Heap)**

- **功能**：存储对象实例的区域，也是 Java 内存管理的主要区域。几乎所有的对象都在这里分配内存。
- **特点**：堆内存是所有线程共享的区域，堆区在 JVM 启动时创建。根据垃圾收集机制，堆区通常分为年轻代（Young Generation）和老年代（Old Generation）。
    - **年轻代（Young Generation）**：进一步分为 Eden 区、Survivor 0 区和 Survivor 1 区，主要存放新创建的对象，垃圾回收频率较高。
    - **老年代（Old Generation）**：存放经过多次垃圾回收后仍然存活的对象，垃圾回收频率较低。

 **2. 方法区 (Method Area)**

- **功能**：方法区（也称为永久代（Permanent Generation）在 JDK 1.7 及以前）存储类结构、常量、静态变量和即时编译器（JIT）编译后的代码等数据。
- **特点**：方法区也是所有线程共享的区域。从 JDK 1.8 开始，永久代被移除，取而代之的是元空间（Metaspace）。元空间在本地内存中，而不是在 JVM 内存中。

 **3. 虚拟机栈 (JVM Stack)**

- **功能**：虚拟机栈是线程私有的。它存储的是 Java 方法执行的栈帧（Stack Frame），每个栈帧包含局部变量表、操作数栈、动态链接和方法返回地址等信息。
- **特点**：局部变量表存储方法参数和局部变量，这些数据在编译期确定。

 **4. 本地方法栈 (Native Method Stack)**

- **功能**：为虚拟机使用到的 Native 方法服务。它主要用于**执行（Native）方法。**
- **特点**：本地方法栈也是线程私有的。它可以使用 C 或 C++ 等本地代码实现。

 **5. 程序计数器 (Program Counter Register)**

- **功能**：存储当前线程所执行的**字节码指令的地址**（行号指示器）。如果当前线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。
- **特点**：程序计数器是线程私有的，每个线程都有一个独立的程序计数器。

 

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就**是存放对象实例**，几乎所有的对象实例以及**数组都**在这里分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老年代代(Old Generation)
3. 永久代(Permanent Generation)

**JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存**

![](https://img2.imgtp.com/2024/05/31/RLkvAx6g.png)

## 内存分配和原则



### **1. 年轻代**

*Eden区*

**Eden区**是年轻代（Young Generation）中的一部分，主要用于新创建的对象。大多数新对象首先被分配到Eden区。Eden区相对较小，因为它假设大部分对象很快就会变得不可达，即“短命”的对象。

*Survivor区*

一旦Eden区满，JVM会执行一次**Minor GC**（也称为Young GC），将Eden区中仍然存活的对象复制到两个Survivor区之一（通常称为From或To）。这两个Survivor区轮流充当源区和目标区，以实现对象在两者之间的复制。每次Minor GC后，源区的存活对象被复制到目标区，然后源区被清空。这个过程称为**复制算法**，它简化了内存管理和碎片问题。

### **2. 老年代（Tenured Generation）**

经过几次Minor GC后仍然存活的对象会被晋升到**老年代**。老年代存放长期存活的对象，这里的垃圾回收频率较低，因为大多数对象是持久的。老年代的垃圾回收通常涉及`Major GC`或`Full GC`，使用**标记-清除**或**标记-整理**算法，这两种算法比复制算法更为复杂和耗时。

### **3. 永久代到元空间（PermGen到Metaspace）**

在Java 8之前，类的元数据（如类的结构信息）存储在**永久代（Permanent Generation, PermGen）中。永久代也是垃圾回收的目标之一，但由于其大小固定，容易出现PermGen OutOfMemoryError**。从Java 8开始，永久代被**元空间（Metaspace）**取代，元空间使用本地内存而不是堆内存，这意味着它的大小不再受JVM堆大小的限制。

- **Metaspace**存储类的元数据，包括类的结构信息。元空间的大小可以动态扩展，直到操作系统无法分配更多内存为止。元空间的垃圾回收主要是针对那些不再被任何类加载器引用的类元数据进行回收，这通常在类加载器自身被垃圾回收时发生。

- Metaspace是干什么的
  
    Metaspace是Java虚拟机（JVM）中用于存储类元数据的内存区域，它在Java 8及之后的版本中引入，用来替代先前的永久代（Permanent Generation）。元数据包括类的结构信息（如类名、方法、字段等）、方法元数据（如字节码、常量池等）以及其他用于描述类和接口所需的运行时数据。
    
    在Java 8之前的版本中，类元数据存储在永久代中，永久代是堆内存的一部分，其大小是固定的，这有时会导致诸如`java.lang.OutOfMemoryError: PermGen space`这样的问题，特别是在类加载频繁的应用场景下。Metaspace的引入解决了这些问题，主要有以下几个关键点：
    
    1. **动态分配与回收**：Metaspace位于本地内存中，而非JVM堆内存，这意味着它的大小不再受JVM堆大小的直接限制，可以更灵活地进行动态扩展。当类和类加载器不再被使用时，它们所占用的Metaspace空间可以被回收，从而减少内存泄漏的风险。
    2. **减少内存限制冲突**：由于Metaspace不占用堆内存，减少了堆内存与永久代之间因大小配置不当而引起的内存限制问题。
    3. **提高性能**：Metaspace的管理去除了永久代中与垃圾回收相关的复杂性，减少了Full GC的发生概率，提高了应用程序的性能。Metaspace的回收不依赖于传统的垃圾回收过程，而是与类加载器的生命周期紧密相关，当类加载器被卸载时，其所加载的类的元数据也会被回收。
    4. **配置灵活性**：用户可以通过JVM参数（如`XX:MetaspaceSize`初始化大小、`XX:MaxMetaspaceSize`最大大小）来控制Metaspace的大小，从而更好地适应不同的应用需求。
    
    尽管Metaspace的引入极大地改善了类元数据的管理，但如果不加以适当控制，Metaspace的大小仍有可能无限制地增长，最终耗尽系统可用的本地内存，导致`java.lang.OutOfMemoryError: Metaspace`错误。因此，监控和合理配置Metaspace对于维护Java应用的稳定运行至关重要。
    

**总结：**

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区

## 死亡对象判断

### 1.引用对象计数法

原理：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很<u>难解决对象之间循环引用</u>的问题。

![](https://img2.imgtp.com/2024/05/31/jC2tgaS7.png)

如上图，无法计数清零

### **2.可达性分析算法**

到 GC Roots 不可达，因此为需要被回收的对象。下图中的 `Object 6 ~ Object 10` 之间虽有引用关系，无法到GC Roots

![](https://img2.imgtp.com/2024/05/31/DvHZqPWQ.png)

- **哪些对象可以作为 GC Roots 呢？**
    - 虚拟机栈(栈帧中的局部变量表)中引用的对象
    - 本地方法栈(Native 方法)中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 所有被同步锁持有的对象
    - JNI（Java Native Interface）引用的对象

## 引用四种类型

![Java 引用类型总结](https://oss.javaguide.cn/github/javaguide/java/jvm/java-reference-type.png)

**强饮用**

垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

创建一个对象 `Person person = new Person();` 这里的 `person` 就是一个强引用。

**软引用**

软引用的对象在内存充足时会被保留，但如果内存变得紧张，垃圾回收器就会回收这些对象来释放内存，以避免OutOfMemoryError。

**弱引用（Weak Reference）**

弱引用的对象在垃圾回收时一定会被回收，哪怕内存还很充裕。它用来标记那些不是必须保留的对象。

虚引用

更像是一个通知机制，告诉你可以执行某些操作了，但它本身对对象的生命周期没有任何影响。

## 死亡常量

  [**如何判断一个类是无用的类？**](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB)

  方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

  判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”**：

  该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

 加载该类的 `ClassLoader` 已经被回收。

  该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 垃圾整理算法

### **标记-清除算法**

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。

![](https://img2.imgtp.com/2024/05/31/gGzVifZu.png)

### 复制算法

内存分为大小相同的两块 。 存活的对象复制到另一块去，然后再把使用的空间到另一块一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

![](https://img2.imgtp.com/2024/05/31/iMlTTAsu.png)

### 标记-整理算法 

“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接覆盖边界以外的内存。

### 不同代不同算法

1. **新生代（Young Generation）**：
    - **复制算法（Copying Algorithm）**：新生代通常采用复制算法进行垃圾回收。这种算法将新生代分为两个相同大小的区域：Eden区和两个Survivor区（一般是From区和To区）。对象首先被分配到Eden区，当Eden区满时，会触发Minor GC（新生代垃圾回收）。Minor GC 会将存活的对象复制到其中一个Survivor区，并清理掉无用对象。经过多次Minor GC 后，存活的对象会被复制到另一个Survivor区或者晋升到老年代。
2. **老年代（Old Generation）**：
    - **标记-清除算法（Mark-Sweep Algorithm）标记-整理算法（Mark-Compact Algorithm）或者分代收集算法（Generational Collection）**：老年代一般使用标记-清除算法进行垃圾回收。这种算法分为标记和清除两个阶段。首先，标记阶段会标记所有活跃的对象，然后在清除阶段将未标记的对象清除掉，释放内存空间。但是，标记-清除算法有可能会导致内存碎片化，影响后续对象的分配。因此，一些垃圾回收器会结合其他算法来优化老年代的垃圾回收，如标记-整理算法（Mark-Compact Algorithm）或者分代收集算法（Generational Collection）。
3. **永久代/元空间（Permanent Generation/Metaspace）**：
    - **标记-整理算法（Mark-Compact Algorithm）**：永久代（在Java 8 之前）或者元空间（在Java 8 及之后）通常使用标记-整理算法进行垃圾回收。这种算法会标记所有活跃的对象，然后将它们整理到一端，清理掉未标记的对象，并释放内存空间。
> 如果说垃圾回收算法是理论，那么这篇大概就是算法的实现
> 

JDK 默认垃圾收集器（使用 `java -XX:+PrintCommandLineFlags -version` 命令查看）：

- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1

### **Serial 收集器**

> 单线程，STW
> 

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![](https://img2.imgtp.com/2024/05/31/8lLti94P.png)

 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。

运行在 Client 模式下的虚拟机来说是个不错的选择。

### [****](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#parnew-%E6%94%B6%E9%9B%86%E5%99%A8)

### `ParNew` 收集器 

`ParNew` 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

![](https://img2.imgtp.com/2024/05/31/dOmemKjz.png)

运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

### Parallel Scavenge 收集器

关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

 ![](https://img2.imgtp.com/2024/05/31/RuiDCQpX.png)

### CMS 收集器 

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

 ![](https://img2.imgtp.com/2024/05/31/YLpOvBo5.png)

CMS 收集器

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

**CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。**

### **G1 收集器**

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。 。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

![](https://img2.imgtp.com/2024/05/31/fNi16T4c.png)

G1 收集器

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。**

## 类加载过程

开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。

- 类加载过程：**加载->连接*->初始化**。
- **连接***过程又可分为三步：**验证->准备->解析**。

![](https://img2.imgtp.com/2024/05/31/vdpeZFkj.png)

1. **加载（Loading）**:
    - 这是类加载过程的第一个阶段。JVM通过类的**全限定名**找到对应的**.class**文件，然后读取文件的二进制数据到内存中，并创建一个`java.lang.Class`对象来代表这个类。这个过程由类加载器（ClassLoader）负责，包括启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、系统类加载器（Application ClassLoader）或用户自定义的类加载器。
2. 链接
    1. **验证（Verification）**:
    - 为了保证类的**正确性**，加载后的字节码需要经过验证，确保其遵守Java**语言规范**和JVM规范，不会对JVM的安全性构成威胁。
    - 验证包括文件格式验证、元数据验证、字节码验证和符号引用验证等多个层次。
    
    **b. 准备（Preparation）**:
    
    - 在这个阶段，JVM为类的静态变量分配内存空间，并赋予默认的初始值。例如，int类型的静态变量初始化为0，布尔型为false，引用类型为null。注意，这个阶段不会执行任何Java代码。
    
    **c. 解析（Resolution）**:
    
    - 类中的符号引用（如类名、方法名等）被转换为直接引用（实际内存地址）。这个过程可以延迟到运行时进行，即所谓的动态链接，以支持Java的动态绑定特性。
3. **初始化（Initialization）**:
    - 这是类加载过程的最后一步，也是真正执行Java代码的地方。在这个阶段，JVM会执行类的静态初始化块和静态变量的显式赋值操作，以及调用静态初始化器。类的初始化顺序遵循以下规则：
        - 父类的静态成员和静态初始化块先于子类执行。
        - 如果有多个静态初始化块或静态变量，按照它们在代码中的顺序执行。
    - 初始化阶段仅执行一次，除非显式调用了`Class.forName()`或通过反射访问类的静态方法或变量，否则类的初始化是在其主动使用时触发的。
    
    ## 双亲委派
    
    类加载器在接收到类加载的请求时，并**不会立即自己**去尝试加载这个类，而是先将加载请求**委托给其父类加载器**去完成。如果父类加载器能够完成类加载任务，那么子加载器就不需要再尝试加载；如果**父类加载器无法**完成此任务，那么**子加载器才会**尝试自己加载。
    
    这个过程会**一直向上**委托，直至到达最**顶级**的启动类加载器。如果启动类加载器也未能找到所需加载的类，那么加载请求会逐级回退，由下一级类加载器进行尝试。这种自顶向下的委托模式可以确保类的唯一性，即一个类只会被加载一次，而且是由它最合适的加载器加载。
    
    ![](https://img2.imgtp.com/2024/05/31/4O07dTo8.png)
    
    主要优点包括：
    
    1. **避免类的重复加载**：确保了每个类在JVM中只有一个唯一的实例，防止了同一个类被不同的类加载器重复加载。
    2. **保证Java平台的稳定性**：因为Java的核心库都是由启动类加载器加载的，这样就可以防止用户自定义的类覆盖这些核心类，保护了Java平台的安全性和稳定性。
    3. **支持类加载器的层级体系**：构建了一个从上至下的父子层级关系，使得类的加载过程具有良好的层次性和规划性。
